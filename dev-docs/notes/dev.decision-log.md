---
id: lemvnlo09cw54zczwbgyhvw
title: Decision Log
desc: ''
updated: 1771779491637
created: 1771779490894
---

## Decision Log Template

- Decision:
- Owner:
- Date:
- Why:
- Tradeoffs:
- Follow-up tasks:

## Decisions (Locked for MVP)

### CLI Framework

- Decision: Use Deno standard-library argument parsing (`@std/cli`) with a small in-repo command router for `start`, `stop`, `status`, `clean`, and `export`. Do not add Cliffy in MVP.
- Owner: Kato engineering
- Date: 2026-02-22
- Why:
  - Command surface is small and stable for MVP.
  - Keeps dependency/supply-chain risk low and aligned with `dev.security-baseline` non-stdlib justification rules.
  - Supports strict command grammar defaults without framework indirection.
- Tradeoffs:
  - No autogenerated command help/completions from a full CLI framework.
  - We own basic usage text, validation, and command dispatch wiring.
- Follow-up tasks:
  - Add `apps/daemon/src/cli/` with parser + command router and tests.
  - Enforce fail-closed behavior for unknown commands/flags.
  - Re-evaluate Cliffy only if command surface/UX needs outgrow in-repo routing.
- MVP defaults:
  - Unknown command or unknown flag is a hard error.
  - No permissive alias behavior unless explicitly added.
  - Strict grammar remains default (legacy permissive parsing stays opt-in only).

### Logging Baseline

- Decision: Use an in-repo structured logger facade for MVP (no third-party logging package), with JSONL output and separate operational vs security-audit sinks.
- Owner: Kato engineering
- Date: 2026-02-22
- Why:
  - Aligns with `dev.security-baseline` requirement to separate security audit logs from operational logs.
  - Minimizes external dependencies while behavior is still being shaped.
  - Keeps local-first/no-network behavior simple and deterministic.
- Tradeoffs:
  - We forego advanced transport/rotation features from mature logging libraries.
  - We own a small amount of formatting/sink plumbing in daemon code.
- Follow-up tasks:
  - Add `apps/daemon/src/observability/logger.ts` and `apps/daemon/src/observability/audit_logger.ts`.
  - Define an event schema/version for log records.
  - Add redaction tests for sensitive fields and audit-completeness tests for allow/deny decisions.
- MVP defaults:
  - Format: JSONL.
  - Operational level: `info` (with `debug` opt-in).
  - Security audit events always write to dedicated audit log sink.
  - Operational and audit records remain separated by sink and schema.

### File Watching

- Decision: Use native `Deno.watchFs` with an in-repo debounce/settle utility. Do not use `chokidar`.
- Owner: Kato engineering
- Date: 2026-02-22
- Why:
  - `chokidar` is a heavy dependency with deep node-gyp/fsevents roots.
  - Deno's native watcher is sufficient for the MVP scope (local text files).
- Tradeoffs:
  - We must implement our own "write settling" logic (debounce) to handle editors that write via temp-rename or multiple flush events.
- Follow-up tasks:
  - Add `apps/daemon/src/core/watcher.ts` with debounce logic.

### Configuration & Parsing

- Decision:
  - Config: Use inline type guards at boundary surfaces (runtime config, control-plane payloads, and state parsing). No `zod` in MVP.
  - Keep environment handling Deno-native; no `dotenv` package (use `deno --env`).
  - Streams: Use `@std/streams` (`TextLineStream`) for all file processing.
- Owner: Kato engineering
- Date: 2026-02-22
- Why:
  - Leverages Web Standards (Streams) and Deno native features.
  - Inline guards provide fail-closed runtime validation with minimal dependency surface.
- Tradeoffs:
  - More manual validation boilerplate than schema-library-driven parsing.
- Follow-up tasks:
  - Re-evaluate `zod` post-MVP if boundary complexity grows substantially.

### Service Mode

- Decision: Defer OS service-manager integration to post-MVP (`systemd`, launchd, Windows Service).
- Owner: Kato engineering
- Date: 2026-02-22
- Why:
  - Current development/testing environment is WSL2 and does not provide a reliable systemd-capable test target.
  - Service wiring does not block the core MVP capture/export architecture.
- Tradeoffs:
  - Daemon lifecycle remains CLI-managed in MVP rather than OS-native service managed.
- Follow-up tasks:
  - Revisit service-manager integration after core daemon interfaces are stable and Linux-native test coverage is available.

### OpenFeature

- Decision: Include OpenFeature in MVP from the start.
- Owner: Kato engineering
- Date: 2026-02-22
- Why:
  - Establishes a stable feature-evaluation contract early, avoiding a second rollout later.
  - Aligns with future centralized config and cross-app policy control.
- Tradeoffs:
  - Adds up-front integration effort and a small amount of initial abstraction overhead.
- Follow-up tasks:
  - Define feature flag contract in `shared/src/contracts/config.ts`.
  - Add a local/offline provider default for MVP and keep network dependency optional.
  - Add tests for deterministic fallback behavior when remote flag providers are unavailable.

### Step 4 Config/OpenFeature Baseline

- Decision:
  - Add typed `featureFlags` to runtime config contract.
  - Validate runtime config with fail-closed behavior, including rejection of unknown feature flag keys.
  - Keep OpenFeature MVP provider local/in-memory only (no network dependency).
- Owner: Kato engineering
- Date: 2026-02-23
- Why:
  - Locks a stable feature-evaluation contract early for daemon/web/cloud evolution.
  - Prevents permissive startup behavior on malformed or unrecognized config.
  - Keeps local-first reliability and deterministic behavior for MVP.
- Tradeoffs:
  - Older daemon builds will refuse newer configs with unknown flags until versions align.
  - Minimal local provider lacks targeting/rollout features (intentionally deferred).
- Follow-up tasks:
  - Add explicit versioning/migration strategy for feature flags beyond MVP.
  - Revisit remote/centralized flag provider once cloud control-plane is active.

### Step 4 Daemon Startup Hardening

- Decision:
  - Introduce fail-closed subprocess startup path that loads runtime config before entering runtime loop.
  - Runtime subprocess exits non-zero on config load/validation failure.
- Owner: Kato engineering
- Date: 2026-02-23
- Why:
  - Prevents daemon from running with implicit defaults when config is missing/corrupt.
  - Aligns startup semantics with security baseline and documented fail-closed policy.
- Tradeoffs:
  - Startup will fail for recoverable config mistakes until user runs explicit correction/init flow.
- Follow-up tasks:
  - Add CLI diagnostic tooling for config validation (`kato config validate`) post-MVP.
  - Add schema migration helpers when config schema evolves.

### Step 4 Export Loader Contract

- Decision:
  - Add provider-aware loader hook (`loadSessionSnapshot`) to runtime export handling.
  - Retain fallback loader (`loadSessionMessages`) for compatibility.
  - Keep provider fallback value `"unknown"` when provider mapping is unavailable.
- Owner: Kato engineering
- Date: 2026-02-23
- Why:
  - Preserves current behavior while allowing provider identity to flow into export/audit paths.
  - Enables incremental wiring of provider ingestion without reworking control-plane contract.
- Tradeoffs:
  - Dual loader hooks add temporary API overlap.
  - Provider identity can remain degraded until ingestion wiring is complete.
- Follow-up tasks:
  - Prefer `loadSessionSnapshot` as canonical hook and retire legacy loader after wiring.
  - Ensure provider/session source-of-truth is documented for runtime and audit consumers.

### Runtime Config Bootstrap

- Decision: Add explicit runtime config bootstrap via `kato init`, with optional auto-bootstrap on `kato start` controlled by `KATO_AUTO_INIT_ON_START` (default `true`).
- Owner: Kato engineering
- Date: 2026-02-22
- Why:
  - Preserves `stenobot`-style first-run ergonomics while keeping explicit config materialized on disk.
  - Keeps startup behavior deterministic for CLI, daemon launch paths, and path-policy configuration.
- Tradeoffs:
  - Adds one additional CLI command and config lifecycle surface.
  - Auto-bootstrap behavior can mask missing manual setup unless disabled.
- Follow-up tasks:
  - Expand runtime config contract in Step 4 with OpenFeature/provider settings.
  - Add boundary validation hardening for config overrides and invalid schema migration paths.

### Writer Identity And Command Semantics

- Decision:
  - Use generated `recordingId` per recording stream (not provider `sessionId`), so one session can drive multiple recordings.
  - Preserve `::record` and `::capture` as distinct behaviors:
    - `::record`: ongoing stream append target.
    - `::capture`: one-shot snapshot export that does not replace active recording stream.
- Owner: Kato engineering
- Date: 2026-02-22
- Why:
  - `stenobot` behavior depends on `record` vs `capture` distinction.
  - Session IDs are provider identities and should not collapse multiple destination streams.
- Tradeoffs:
  - Adds routing/state complexity in writer orchestration (stream identity + session identity).
  - Requires explicit tests to avoid accidental conflation.
- Follow-up tasks:
  - Add writer routing contract for `(provider, sessionId) -> active recording streams`.
  - Add tests for multiple recording streams per session and capture-without-rotation behavior.

### Frontmatter ID Format

- Decision: Use compact frontmatter IDs for user-facing note files: `<slug>-<randomSuffix>` using an in-repo utility (no extra dependency).
- Owner: Kato engineering
- Date: 2026-02-22
- Why:
  - Better readability in note-centric workflows than full UUIDs.
  - Keeps dependency surface minimal while satisfying uniqueness/readability needs.
- Tradeoffs:
  - ID slug may drift from filename after renames; accepted for MVP.
  - Compact suffix has higher (still low) collision risk vs UUID; must size suffix accordingly.
- Follow-up tasks:
  - Implement local slug+suffix ID utility and collision tests.
  - Keep runtime/internal IDs on `crypto.randomUUID()` unless explicitly user-facing.
